The problem is that the semantics of cilk spawns are not the same when a
variable is assigned and declared, and when a variable is first declared and
then assigned. 

I did a test of a regular C program using only the stdlib where I compared
the generated assembly of 

  int i = foo();

  and 

  int i;
  i = foo();

They generate identical assembly, however Cilk seems make a distinction between
the two. is this the correct behavior?


I have included a small test program that demonstrates the behavior in
question and generated two dump files of the assembly. The first is
doesnotspawn.dump, and corresponds to the first code snippet above. 
the second, called doesspawn.dump, corresponds to the second code snippet
above.

in doesnotspawn.dump:

go to line 287, and observe that there is no spawn.
There is a serial call to reader, despite the source having a spawn.

in doesspawn.dump:

go to line 349. Observe that we call an actual spawn, and reader is called within
the code for spawn_001.2187 (line 225). I believe this is the correct behavior.   


the resulting error is that the continuation of reader cannot be stolen in 
doesnotspawn.dump. This leads to a deadlock as the ivar will never be written
since the write happens in the continuation of read, which is now executed
in serial. 


This is not only an error with cilk ivars. this can be duplicated on standard
cilk programs. See the stdcilk directory and compare the object dumps.
doesnotspawn.dump in that directory has NO spawn tags.


